h2. Keyboard input and binding to events

Events is how components in Crafty talk to each other. In this article we will bind to events from Craftys Keyboard component to make it possible for a player to control the main character.

The following code will create the player entity. The Ape component provides collision handling and some nice walking animations. We shall create this component in a moment. The LeftControls component will handle keyboard input and BombDropper will give out hero the ability to throw bombs. You may recall from the last article that we defined a sprite component called player:

<code>
        //create our player entity with some premade components
        var player1 = Crafty.e("2D, DOM, Ape, player, LeftControls, BombDropper")
                .attr({ x: 16, y: 304, z: 1 })
                .leftControls(1)
                .Ape();
</code>

The entity is positioned in the bottom left corner and the constructors for two of the entities components are called. Lets build the LeftControls component right away to get our player moving:

<code>
    Crafty.c("LeftControls", {
        init: function() {
            this.requires('Multiway');
        },
        
        leftControls: function(speed) {
            this.multiway(speed, {W: -90, S: 90, D: 0, A: 180})
            return this;
        }
        
    });
</code>

As you can see it is pretty easy to define a component. The LeftControls component has two functions. 
These functions are added to new entities that are created with this component, like the player1 entity above. 
This means that the this keyword will point to the specific entity the function is called on. 
init is a magic function that is called by crafty right after a new entity has been created.

When you want to be able to change the behavior of the component in different entities you need some way to pass a parameter the initialization code. For this purpose it is convention to create a constructor that must be called when a entity is created. In this case the variability point is the speed of the entity.

We take advantage of the Multiway component that is part of Crafty. It is initialized by calling its constructor with two arguments: an integer specifying speed and an object with mappings from keyboard input to a direction. In this case we map W-A-S-D to up-left-down-right. The multiway component binds a function to the enterframe event and moves the entity as needed. It also triggers an event when direction changes. we will use this in the Ape component to animate the player when walkink.

Notice how we return the entity object in the leftControls constructor. This convention enables us to chain component constructor calls as we did in the player1 entity: .leftControls(1).Ape();. This convention is follwed throughout the crafty code base and i suggest you do as well.

Now for the Ape component that adds animations and collision detection:

<code>
    Crafty.c('Ape', {
        Ape: function() {
                //setup animations
                this.requires("SpriteAnimation, Collision, Grid")
                .animate("walk_left", 6, 3, 8)
                .animate("walk_right", 9, 3, 11)
                .animate("walk_up", 3, 3, 5)
                .animate("walk_down", 0, 3, 2)
                //change direction when a direction change event is received
                .bind("NewDirection",
                    function (direction) {
                        if (direction.x < 0) {
                            if (!this.isPlaying("walk_left"))
                                this.stop().animate("walk_left", 10, -1);
                        }
                        if (direction.x > 0) {
                            if (!this.isPlaying("walk_right"))
                                this.stop().animate("walk_right", 10, -1);
                        }
                        if (direction.y < 0) {
                            if (!this.isPlaying("walk_up"))
                                this.stop().animate("walk_up", 10, -1);
                        }
                        if (direction.y > 0) {
                            if (!this.isPlaying("walk_down"))
                                this.stop().animate("walk_down", 10, -1);
                        }
                        if(!direction.x && !direction.y) {
                            this.stop();
                        }
                })
                // A rudimentary way to prevent the user from passing solid areas
                .onHit("solid", function () {
                    this.snap();
                }).onHit("fire", function() {
                    this.destroy();
					// Subtract life and play scream sound
                });
            return this;
        }
    });
</code>


Take a look at our sprite sheet:

!bananabomber-sprites.png!

 As our game is tile based, all the graphic elements has the same size: 16x16 pixels. Some of the sprites are single pictures and some (like the player) are part of an animation. In a flash game you would create animations by drawing images on consecutive frames in a movieclip, and as you will see shortly Crafty has a similar concept.

 To be able to work with these sprites in Crafty we must cut them out of the sheet and give them names:

<code>
    //turn the sprite map into usable components
    Crafty.sprite(16, "sprite.png", {
        grass1: [0, 0],
        grass2: [1, 0],
        grass3: [2, 0],
        grass4: [3, 0],
        flower: [0, 1],
        bush1: [0, 2],
        bush2: [1, 2],
        player: [0, 3],
        enemy: [0, 3],
        banana: [4, 0],
        empty: [4, 0]
    });
</code>

The tile size is specified once, so we can reference the tiles by row and column. This is convenient, but if you are working with sprites of different size you can specify the exact size like this:

<code>
name: [x, y, width, height]
</code>

I will step through the generateWorld method little by little as it shows several new concepts. The general idea is that we will divide the map into 16x16 pixel areas and for each decide what background and elements to put on it:

<code>
    //method to generate the map
    function generateWorld() {
        //loop through all tiles
        for (var i = 0; i < 25; i++) {
            for (var j = 0; j < 21; j++) {

                //place grass on all tiles
                grassType = Crafty.randRange(1, 4);
                Crafty.e("2D, DOM, grass" + grassType)
                    .attr({ x: i * 16, y: j * 16, z:1 });
</code>

First we create some grass background. We use the 2D and DOM components to give the entity coordinates and the ability to draw itself to the stage. We also randomly asign it one of the grass1...4 sprite components we have just defined. Any component defined via Crafty.sprite() will automatically instruct either the DOM or the Canvas component to draw it on the stage. Finally we call the attr function on the new entity that will set x and y coordinates. As in flash, the z value specifies what element should be in front when two or more are overlapping. The one with highest z wil be on the top, so we assign the background something low.

To provide a closed playing field for the game we add some bushes around the edges, much the same way as the grass:

<code>
                //create a fence of bushes
                if(i === 0 || i === 24 || j === 0 || j === 20)
                    Crafty.e("2D, DOM, solid, bush" + Crafty.randRange(1, 2))
                    .attr({ x: i * 16, y: j * 16, z: 2 });
</code>

Let's get some more interesting stuff on the stage. Like flowers dancing in the wind scattered over the map...
 
<code>
                //generate some nice flowers within the boundaries of the outer bushes
                if (i > 0 && i < 24 && j > 0 && j < 20
                        && Crafty.randRange(0, 50) > 30
                        && !(i === 1 && j >= 16)
                        && !(i === 23 && j <= 4)) {
                    var f = Crafty.e("2D, DOM, flower, solid, Animate, explodable")
                            .attr({ x: i * 16, y: j * 16, z: 1000 })
                            .animate("wind", 0, 1, 3)
                            .animate('wind', 80, -1)
                            .bind('explode', function() {
                                this.destroy();
                            });
                }
</code>


The flower component adds the flower sprite to the entity. The Animate component adds *surprise, surprise* animation capabilities to the flower. This is used by calling the animate() function on the entity. The first call creates an animation called wind that starts in column 0, row 1 (just as the flower sprite itself) and spans 3 columns. To learn about how to setup more advanced animations have a look in the documentation. 
The second call starts the animation, specifying that it should last 80 frames and play forever(replace -1 with a positive int to specify a number of times the animation should repeat before stopping).

explodable and solid are tagging components. That is they don't have an implementation and are simply used to mark an entity of a given kind. This works very well with Craftys collision functionality that can detect collision with entities that have a given component. We will have a look at that in a later article.

We will finish this article by adding a grid of bushes in true bomberman style:

<code>
                //grid of bushes
                if((i % 2 === 0) && (j % 2 === 0)) {
                    Crafty.e("2D, DOM, solid, bush1")
                        .attr({x: i * 16, y: j * 16, z: 2000})
                }
            }
        }
    }

</code>

Have a look at our wonderfull garden:

!bananabomber-1.png!

Note: % is the modulo operator. It simply divides the left operand with the right operand and returns the remainder. Thus (i % 2 === 0) evaluates to true when i is even. 

If you wonder why i use === instead of just == here is an explanation.
The normal equality operator == does type coercion before checking for equality. This means that all the following expressions return true

<code>
    ('5' == 5)
    (0 == '')
    (0 == false)
    (false == undefined)
    ("\r\n" == 0)
</code> 

The first one is sort of okay, but the rest will come and bite you some day. That is why the father of javascript, Douglas Crockford recommends using the strict equality operator, === that will never say values of different types are equal.

Next up is a little detour into the wonders of javascript debugging in the article "Debugging javascript applications":debugging-javascript-applications

